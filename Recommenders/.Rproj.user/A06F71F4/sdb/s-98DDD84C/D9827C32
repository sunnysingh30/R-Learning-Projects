{
    "contents" : "rm(list=ls())\n\nlibrary(recommenderlab)\nhelp(package=\"recommenderlab\")\n\nset.seed(1)\ndata_pkg <- data(package = \"recommenderlab\")\n\nnames(data_pkg)\ndata_pkg$results[, \"Item\"]\n\ndata(\"MovieLense\")\nMovieLense\n\n#Class for rating matrix\nclass(MovieLense)\n\n#Method we can apply on this class -- realRatingMatrix\nmethods(class=class(MovieLense))\n\n\n#Compare the size of MovieLense with the corresponding R matrix:\nobject.size(MovieLense)\nobject.size(as(MovieLense, \"matrix\"))\n\n#Compute how many time recommenderlab is compact\nobject.size(as(MovieLense, \"matrix\"))/object.size(MovieLense)\n\n\n\n## Computing similarity matrix\nsimilarity_usr <- similarity(MovieLense[1:4,], method = \"cosine\", which=\"users\")\nsimilarity_usr\nclass(similarity_usr)\n\nas.matrix(similarity_usr)\nimage(as.matrix(similarity_usr), main=\"usr matrix\")\n\n\n## Recommendation models\nrecommender_models <- recommenderRegistry$get_entries(dataType=\"realRatingMatrix\")\nnames(recommender_models)\n\nrecommender_models$UBCF_realRatingMatrix\nrecommender_models$IBCF_realRatingMatrix\n\n\n##############################################################################\n#DATA EXPLORATION\n#In this section we will use recommender to build recommender sys and ggplot2 \n#Load packages\n\nlibrary(recommenderlab)\nlibrary(ggplot2)\ndata(\"MovieLense\")\nclass(MovieLense)\n\n\n#Exploring the nature of data\ndim(MovieLense)\nvec_rat <- as.vector(MovieLense@data)\nunique(vec_rat)\n\ntable_rat <- table(vec_rat)\nvec_rat <- vec_rat[vec_rat != 0]\n\nvec_rat <- factor(vec_rat)\nplot(vec_rat)\nqplot(vec_rat) + ggtitle(\"Distribution of the ratings\")\n\n\n#Exploring which movies have been viewed\nviews_per_movie <- colCounts(MovieLense)\nnames(views_per_movie)\n\n#Sort the movies by number of views\ntable_views <- data.frame(\n  movie = names(views_per_movie),\n  views = views_per_movie\n)\n\ntable_views <- table_views[order(table_views$views, decreasing = T), ]\n\n#Visualize 1st 6 rows and build histogram\nggplot(table_views[1:6,], aes(x=movie, y=views)) + \n  geom_bar(stat=\"identity\") +\n  theme(axis.text.x = element_text(angle=45, hjust=1)) +\n  ggtitle(\"Number of views of top movies\")\n\n\n## Exploring average ratings\navg_rat <- colMeans(MovieLense)\nqplot(avg_rat) + \n  stat_bin(binwidth = 0.1) + \n  ggtitle(\"Distribution of avg movie rating\")\n\n\n#Exclude the movies whose views is below 100\navg_rat_rel <- avg_rat[views_per_movie >100]\n\nqplot(avg_rat_rel) + \n  stat_bin(binwidth=0.1) +\n  ggtitle(paste(\"Distribution of relevant avg ratings\"))\n\n\n## Visualizing Matrix :: Heat map whose colors represent ratings\nimage(MovieLense, main=\"Heatmap of ratings matrix\")\nimage(MovieLense[1:10, 1:15], main=\"Heatmap of ratings matrix\")\n\n\n# Selecting most relevant users:\n# Visualizing only users that have seen many movies and movies tha have been\n# seen by many users. \n## To identify and select most relevant users follow below steps:\n\n1 - Determine minimum number of movies per user.\n2 - Determine minimum number of usrs per movie.\n3 - Select users an movies matching this criteria.\n\n# We use QUANTILE() funtion :\n?quantile\nmin_n_movies <- quantile(rowCounts(MovieLense), 0.99)\nmin_n_usr <- quantile(colCounts(MovieLense), 0.99)\nmin_n_movies\nmin_n_usr\n\nimage(MovieLense[rowCounts(MovieLense) > min_n_movies,\n                 colCounts(MovieLense) > min_n_usr ],\n      main= \"Heatmap of the top users and movies\")\n\n\n## TILL NOW WE HAVE EXPLORED THE MATRIX. \n## After observing above heatmap we might have to normalize the data\n# to be considered as input for recommendation models.\n\n##################################################\n## DATA PREPARATION\nThis section will show how to prepare the data to be used in recommender models\nFollow below steps:\n-  Select relevant data\n-  Normalize the data.\n\n# Selecting most relevant data\nWe will define rating matrix that will take into account:\n-  Users who have rated 5 movies\n-  Movies that have been watched atleast 100 times\n\nrating_movies <- MovieLense[rowCounts(MovieLense) > 50, colCounts(MovieLense)>100]\nclass(rating_movies)\n\n# Xploring most relevant data.\n# -- Lets visualize top 2% of users\n\n# Visualize top matrix\nmin_movies <- quantile(rowCounts(rating_movies), 0.98)\nmin_usrs <- quantile(colCounts(rating_movies), 0.98)\n\nimage(rating_movies[rowCounts(rating_movies)>min_movies, \n                    colCounts(rating_movies)>min_usrs])\n\n# As observed that some rows are darker and some are lighter.\nSome users give higher ratings to all movies.\nHowever, we have visualized only top movies. \nIn order to have an overview of all users, lets take look\nat the distribution of the avg ratings by user:\n################# --------------------------------------\n\navg_rat_per_usr <- rowMeans(rating_movies)\n\nqplot(avg_rat_per_usr) +\n  stat_bin(binwidth = 0.1) +\n  ggtitle(\"Distribution of avg rating per user\")\n\n# The avg rating per user varies alot accross different users\n\n## NORMALIZING THE DATA ###########################\nHaving users that might give high rating to all their movies might bias\nthe results. Hence, lets normalize the data.\n\nrating_movies_norm <- normalize(rating_movies)\n\n# Lets take look at average rating by users.\nsum(rowMeans(rating_movies_norm) > 0.00001)\n\n# As expected mean rating of each user is 0(apart from approx. error).\n# We can visualize new matrix using 'image'. \n# Lets build heatmap\n\nimage(rating_movies_norm[rowCounts(rating_movies_norm) > min_movies,\n                         colCounts(rating_movies_norm)> min_usrs],\n      main = \"Heatmap of top users and movies\")\n\n\n## Binarizing the data\nSome recommendation models works on binary data, so we might want to binarize our\ndata, that is, define a table containing only 0s and 1s. The 0s will be either \ntreated as missing values or as bad ratings.\n\nIn our case we can either:\n-  Define matrix having 1 if the user rated movie, ad 0 otherwise. In this case, \nwe are losing the information about rating.\n-  Define matrix having 1 if the rating is above or equal to a define threshold value \n  (example 3), and 0 otherwise. In this case giving bad rating to the movie is \n    equivalent to having not rated it.\n\nDepending on the context, one choice is more approriate than pther\n####################--------------------------------------------\n\nrating_movies_watched <- binarize(rating_movies, minRating=1)\nmin_movies_binary <- quantile(rowCounts(rating_movies), 0.95)\nmin_usrs_binary <- quantile(rowCounts(rating_movies), 0.95)\n\nimage(rating_movies_watched[rowCounts(rating_movies) > min_movies_binary,\n                            colCounts(rating_movies) > min_usrs_binary])\n\n\n####### Lets use same approach to compute and visualize the other binary matrix.\n#The cells having rating above threshold will have their value to 1 and other cells \n#will be 0s\n\n\nrating_movies_good <- binarize(rating_movies, minRating=3)\nimage(rating_movies_good[rowCounts(rating_movies) > min_movies_binary,\n                         colCounts(rating_movies)> min_usrs_binary])\n# As expected we have more white cells now.\nIn this section we prepared and the data to perform recommendations. In the upcoming\nsection, we will build collaborative filtering models.\n\n\n################################################################################\n#################### ITEM BASED COLLABORATIVE FILTERING #######################\nCollaboratetive refers to that the users collaborate with each other to \nrecommend items.\nIn fact, algortithms take account of user purchases and preferences.\n\nExample of IBCF, given an user the algo considers the users'' purchase and recommends\nsimilar items. The core algorithm is based on these steps:\n  - For each 2 items, measure how similar they are in terms of having received \nsimilar ratings by similar users.\n  - For each item identify k-most similar items.\n  - For each user, identify items that are most similar to the users'' purchases.\n##############################--------------------------------------------------\n\n# Defing traing and test dataset.\nwhich_train <- \n  sample(x=c(T,F), size=nrow(rating_movies), replace=T, prob=c(0.8, 0.2))\n\nhead(which_train)  \n\nrecc_data_train <- rating_movies[which_train, ]\nrecc_data_test <- rating_movies[!which_train,]\n\n# If we want to recommen items to each user, we could just use k-fold:::::\n- Split the users randomly in 5 groups.\n- Use a group as test and other groups as training sets.\n- Repeat it for each group.\n\nSample Code:\n  which_set <- sample(x=1:5, size=nrow(rating_movies), replace=T)\n  for(i_model in 1:5){\n    which_train <- which_set == i_model\n    recc_data_train <- rating_movies[which_train,]\n    recc_data_test <- rating_movies[!which_train,]\n    #build the recommender.\n  }\n\n\n### Buildign the recommendation model.\nfntion to build recommender models and its inputs are as follows:\n  - data\n  - Method\n  - Parameters\nThe model is called IBCF, which stands fr item-based collaborative filtering.\n\nrecommender_models <- recommenderRegistry$get_entries(dataType=\"realRatingMatrix\")\nrecommender_models$IBCF_realRatingMatrix$parameters\n\n\nrecc_model <- Recommender(data=recc_data_train, method=\"IBCF\", \n                          parameter=list(k=30))\nclass(recc_model)\n\n\n# Exploring the RECOMMENDER MODEL\nmodel_details <- getModel(recc_model)\nnames(model_details)\n\nmodel_details$description\nmodel_details$k\n\nmodel_details$sim  # Its square matrix contains similarity matrix\nclass(model_details$sim)\n\n# Lets build heat map\nn_top_items <- 20\nimage(model_details$sim[1:n_top_items, 1:n_top_items], \n      main=\"Heat map of the first rows and columns\")\n\n# Most of the values are equal to 0. The reason is that each row \n#contains only k elements. Let's check it:\n\nmodel_details$k\nrow_sums <- rowSums(model_details$sim >0)\ntable(row_sums)\n?rowSums\n\nhead(model_details$sim, 2)\n",
    "created" : 1451395952962.000,
    "dirty" : true,
    "encoding" : "",
    "folds" : "",
    "hash" : "737921477",
    "id" : "D9827C32",
    "lastKnownWriteTime" : 8316297137719964271,
    "path" : null,
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled3"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}